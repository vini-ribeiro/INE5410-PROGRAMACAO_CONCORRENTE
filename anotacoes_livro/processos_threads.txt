1. processo: uma instância de um programa em execução

2. A CPU alterna a execução de vários processos para dar a impressão, para o usuário do sistema operacional, de que os processos estão sendo executados paralelamente (pseudoparalelismo).

3. À esse método de trocas de processos chamamos de multiprogramação.

4. CPU virtual: uma abstração para melhor lidarmos com a alternância de processos nas CPUs físicas. Cada processo tem sua CPU virtual.

5.
Programa: é a receita de bolo
Processo: é o ato de fazer o bolo
Dados: são os ingredientes
CPU: o confeiterio

6. Em sistemas simples, como em controladores de dispositivos domésticos (microondas), é possível ter todos os processos que em algum momente serâo executados. Mas em sistemas mais complexos isso não é possível e será necessário a criação (e sua destruição) de tais processos.

7.
        "Quatro eventos principais fazem com que os proces-
        sos sejam criados:
        1. Inicialização do sistema.
        2. Execução de uma chamada de sistema de criação
        de processo por um processo em execução.
        3. Solicitação de um usuário para criar um novo
        processo.
        4. Início de uma tarefa em lote."

8. Processos que ficam em segundo plano (email, pag web, etc) são chamados daemons.

9. No UNIX há apenas uma chamada de sistema que cria um processo: o fork(). Essa chamada cria um clone exato do processo atual, mas em um novo contexto

10.
        "Cedo ou tarde, o novo processo terminará, normal-
        mente devido a uma das condições a seguir:
        1. Saída normal (voluntária).
        2. Erro fatal (involuntário).
        3. Saída por erro (voluntária).
        4. Morto por outro processo (involuntário)."

11. Em sistemas UNIX, quando o processo pai termina (seja voluntariamente ou não), seus processos filhos não são terminados automaticamente. Viram processos órfãos

12. Considere o comando: "cat texto | grep string". Este comando inicia o processo de leitura do arquivo text e passa pelo filtro grep, primeiro acontece o cat e depois o grep, mas o grep pode já estar pronto para executar antes mesmo do cat terminar. Para isso a execução do grep precisa ser travada.

13. O processo pode ser bloqueado porque a CPU alocou seu processamento para outro processo. Este caso é diferente do tópico 12.

14. Um processo pode se encontrar em 3 estados
    14.1. Em execução (realmente usando a CPU naquele instante).
    14.2. Pronto (executável, temporariamente parado para deixar outro processo ser executado). (o tópico 13 se encaixa aqui)
    14.3. Bloqueado (incapaz de ser executado até que algum evento externo aconteça). (o tópico 12 se encaixa aqui)
    
15. Esquema dos estados (em execução, bloqueado e pronto):
    em execução -> bloqueado ou pronto
    pronto -> em execução
    bloqueado -> pronto
    
    OBS: a transição de pronto para em execução e vice-versa é feita pelo escalonador

OBS: por modelo de processos se entende à todo esse paradigma de termos vários processos e cada um deles ser gerido pelo escalonador e poder dar a ideia de paralelismo (pseudoparalelismo)

16. Tabela de processos (ou blocos de controle de processos): contêm informações importantes sobre o estado do processo, incluindo o seu contador de programa, ponteiro de pilha, alocação de memória, estado dos arquivos abertos, informação sobre sua contabilidade e escalonamento e tudo o mais que deva ser salvo quando o processo é trocado do estado em execução para pronto ou bloqueado, de maneira que ele possa ser reiniciado mais tarde como se nunca tivesse sido parado.

OBS: importante salientar que o sistema operacional mantém uma tabela de processos para cada um dos processos, seja pai, filho, neto, etc.

17. Interrupção: quando há um processo de maior importância que faz o processo atual parar a sua execução na CPU. É algo um tanto complexo então melhor olhar no livro.
    17.1. O hardware empilha o contador de programa etc.
    17.2. O hardware carrega o novo contador de programa a partir do arranjo de interrupções.
    17.3. O vetor de interrupções em linguagem de montagem salva os registradores.
    17.4. O procedimento em linguagem de montagem configura uma nova pilha.
    17.5. O serviço de interrupção em C executa (em geral lê e armazena temporariamente a entrada).
    17.6. O escalonador decide qual processo é o próximo a executar.
    17.7. O procedimento em C retorna para o código em linguagem de montagem.
    17.8. O procedimento em linguagem de montagem inicia o novo processo atual.

18. Threads: é um processo dentro de um processo, a sua maior diferença para um processo é que agora a memória (e todas as variáveis são compartilhadas).
    18.1. Por compartilharem a memória, ela consome menos, sendo mais rápida de criar e destruir, em comparação com um processo.

19. Exemplo do processador de textos:
    Temos 3 threads em um processo, a primeira thread cuida da E/S do teclado/mouse, a segunda da formatação do texto e a terceira do salvamento automático. Não seria nada interessante termos 3 processos pois todos precisariam ter acesso ao conteúdo do texto (memória compartilhada).

pag 71
